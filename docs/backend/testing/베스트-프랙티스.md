# 베스트 프랙티스

## 1. 테스트 작성 가이드

**✅ DO:**
- 테스트 이름을 명확하게 작성 (`@DisplayName` 활용)
- Given-When-Then 패턴 사용
- 하나의 테스트는 하나의 책임만
- AssertJ의 유창한 assertions 사용
- Mockito의 BDD 스타일 사용 (`given()`, `willReturn()`)

**❌ DON'T:**
- 테스트 간 의존성 생성
- 프로덕션 데이터베이스 사용
- 하드코딩된 날짜/시간 (Clock 모킹 사용)
- Sleep/Wait 사용 (Awaitility 사용)
- 과도한 모킹 (실제 객체 우선)

## 2. 테스트 격리

```java
// ✅ Good: 트랜잭션 롤백으로 격리
@Transactional
@Test
void testMethod() {
    // 테스트 후 자동 롤백
}

// ✅ Good: @BeforeEach로 초기화
@BeforeEach
void setUp() {
    testData = createTestData();
}

// ❌ Bad: 정적 변수 공유
private static User sharedUser;  // 테스트 간 간섭
```

## 3. 가독성

```java
// ✅ Good: 명확한 변수명과 구조화
@Test
@DisplayName("사용자 생성 시 중복 이메일이면 예외 발생")
void createUser_WhenDuplicateEmail_ThrowsException() {
    // Given
    String existingEmail = "existing@example.com";
    createUserWithEmail(existingEmail);
    
    UserCreateRequest request = requestWithEmail(existingEmail);
    
    // When & Then
    assertThatThrownBy(() -> userService.createUser(request))
        .isInstanceOf(DuplicateResourceException.class)
        .hasMessageContaining("email");
}

// ❌ Bad: 불명확한 테스트
@Test
void test1() {
    User u = new User();
    u.setEmail("test@test.com");
    assertThat(service.save(u)).isNotNull();
}
```

## 4. 테스트 데이터 빌더 패턴

```java
// TestDataBuilder.java
public class TestDataBuilder {
    
    public static User.UserBuilder aUser() {
        return User.builder()
            .id(UlidGenerator.generate())
            .username("testuser")
            .passwordHash("$2a$12$hash")
            .email("test@example.com")
            .fullName("Test User")
            .status("ACTIVE")
            .createdAt(LocalDateTime.now());
    }
    
    public static UserCreateRequest.UserCreateRequestBuilder aUserCreateRequest() {
        return UserCreateRequest.builder()
            .username("newuser")
            .password("Password123!")
            .email("new@example.com")
            .fullName("New User")
            .orgId(UlidGenerator.generate())
            .permGroupCodes(List.of("PG_USER"));
    }
}

// 사용 예시
@Test
void testWithBuilder() {
    // Given
    User user = aUser()
        .username("customuser")
        .email("custom@example.com")
        .build();
    
    // When & Then
    // ...
}
```

## 5. 비동기 테스트

```java
// Awaitility 사용
@Test
void asyncTest() {
    // When
    service.asyncMethod();
    
    // Then
    await().atMost(5, SECONDS)
        .untilAsserted(() -> {
            verify(repository).save(any());
        });
}
```

## 6. 예외 테스트

```java
// ✅ Good: AssertJ 예외 검증
assertThatThrownBy(() -> service.methodThrowingException())
    .isInstanceOf(CustomException.class)
    .hasMessageContaining("expected message")
    .hasFieldOrPropertyWithValue("errorCode", "ERR_001");

// ❌ Bad: try-catch 사용
try {
    service.methodThrowingException();
    fail("Expected exception not thrown");
} catch (CustomException e) {
    assertThat(e.getMessage()).contains("expected message");
}
```

---
