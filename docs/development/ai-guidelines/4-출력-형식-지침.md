# 4️⃣ 출력 형식 지침

## A. 분석 단계

**형식:**
```markdown
# 📋 작업 분석

**요청 내용:**
- [사용자 요청 요약]

**필요한 작업:**
1. [작업 1]
2. [작업 2]

**사용할 Skills:**
- Code Generation Skill
- Test Generation Skill
- Documentation Skill

**사용할 MCP 도구:**
- File: 코드 파일 생성
- Web: 최신 Spring Security 규칙 조회
```

**예시:**
```markdown
# 📋 작업 분석

**요청 내용:**
- LoginPolicy 엔티티 및 Repository 구현

**필요한 작업:**
1. Domain Layer: LoginPolicy Entity 설계
2. Infrastructure Layer: LoginPolicyRepository 인터페이스
3. Infrastructure Layer: MyBatis Mapper XML
4. 각 레이어별 테스트 작성

**사용할 Skills:**
- DDD Domain Modeling Skill
- MyBatis Code Generation Skill
- JUnit Test Generation Skill

**사용할 MCP 도구:**
- File: Entity, Repository, Mapper 파일 생성
- Web: MyBatis 3.5.x 최신 기능 확인
```

---

## B. 해결물 생성

**원칙:**
- 코드, 문서, 설정 파일 등 필요한 결과물을 완성된 형태로 제시
- 확장성과 재사용성을 고려한 아키텍처로 구성
- 각 파일은 단일 책임 원칙(SRP) 준수

**완성도 기준:**
```
✅ 완성된 예시:
- 컴파일 가능한 완전한 코드
- 모든 import 문 포함
- 테스트 코드 포함
- JavaDoc/주석 포함
- 에러 처리 포함

❌ 불완전한 예시:
- "... 여기에 코드 추가 ..."
- "TODO: 구현 필요"
- import 문 누락
- 테스트 누락
```

**Inspect-Hub 프로젝트 코드 템플릿:**

```java
// ✅ Domain Entity (완성된 형태)
package com.inspecthub.policy.domain;

import lombok.*;
import java.time.LocalDateTime;

import com.inspecthub.common.exception.DomainException;

/**
 * 로그인 정책 도메인 엔티티
 * 
 * 책임:
 * - 로그인 방식(AD, SSO, LOCAL) 활성화 상태 관리
 * - 우선순위 관리
 * - 정책 변경 이력 추적
 */
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@AllArgsConstructor
@Builder
public class LoginPolicy {
    
    private String policyId;           // ULID
    private Boolean adEnabled;
    private Boolean ssoEnabled;
    private Boolean localEnabled;
    private String priority;           // "SSO,AD,LOCAL"
    private LocalDateTime updatedAt;
    private String updatedBy;
    
    /**
     * 활성화된 로그인 방식이 최소 1개 이상인지 검증
     */
    public void validateAtLeastOneEnabled() {
        if (!adEnabled && !ssoEnabled && !localEnabled) {
            throw new DomainException("최소 하나의 로그인 방식이 활성화되어야 합니다");
        }
    }
    
    /**
     * 정책 업데이트
     */
    public void update(Boolean adEnabled, Boolean ssoEnabled, Boolean localEnabled, String priority, String updatedBy) {
        this.adEnabled = adEnabled;
        this.ssoEnabled = ssoEnabled;
        this.localEnabled = localEnabled;
        this.priority = priority;
        this.updatedAt = LocalDateTime.now();
        this.updatedBy = updatedBy;
        
        validateAtLeastOneEnabled();
    }
}

// ✅ 함께 제공되는 테스트
package com.inspecthub.policy.domain;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import static org.assertj.core.api.Assertions.*;

import com.inspecthub.common.exception.DomainException;

class LoginPolicyTest {
    
    @Test
    @DisplayName("모든 로그인 방식이 비활성화되면 예외가 발생한다")
    void shouldThrowExceptionWhenAllMethodsDisabled() {
        // Given
        LoginPolicy policy = LoginPolicy.builder()
            .policyId("01HN2Z3K4M5N6P7Q8R9S0T1U2V")
            .adEnabled(true)
            .ssoEnabled(false)
            .localEnabled(false)
            .build();
        
        // When & Then
        assertThatThrownBy(() -> 
            policy.update(false, false, false, "", "admin"))
            .isInstanceOf(DomainException.class)
            .hasMessageContaining("최소 하나의 로그인 방식");
    }
}
```

---

## C. 후속 조치 제안

**형식:**
```markdown
# 🎯 추가 개선 사항

## 자동화 포인트
- [자동화 가능한 작업]

## 테스트 확장
- [추가 테스트 시나리오]

## 성능 최적화
- [성능 개선 가능성]

## 보안 강화
- [보안 고려사항]
```

**예시:**
```markdown
# 🎯 추가 개선 사항

## 자동화 포인트
- LoginPolicy 변경 시 자동으로 AuditLog 기록하는 AOP 구현
- 정책 변경 시 이메일 알림 자동 발송

## 테스트 확장
- Edge Case: 우선순위 문자열 파싱 실패 시나리오
- 동시성 테스트: 여러 관리자가 동시에 정책 변경 시도

## 성능 최적화
- LoginPolicy 조회 시 Redis 캐싱 (TTL: 5분)
- 정책 변경 이벤트 발행으로 캐시 무효화

## 보안 강화
- 정책 변경 시 2단계 인증 (Maker-Checker)
- 정책 변경 이력 암호화 저장
```

---
