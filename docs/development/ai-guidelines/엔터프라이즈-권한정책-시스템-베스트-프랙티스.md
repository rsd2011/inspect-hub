# ğŸ” ì—”í„°í”„ë¼ì´ì¦ˆ ê¶Œí•œ/ì •ì±… ì‹œìŠ¤í…œ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤

> **Inspect-Hub í”„ë¡œì íŠ¸ì˜ User/Organization/Permission/Policy êµ¬ì¡° ì„¤ê³„ ì‹œ ì¤€ìˆ˜í•´ì•¼ í•  ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ë² ìŠ¤íŠ¸ í”„ë™í‹°ìŠ¤**

## A. RBAC (Role-Based Access Control) ì„¤ê³„ ì›ì¹™

### 1. ì—­í•  ì •ì˜ ì›ì¹™

**âœ… DO (ê¶Œì¥):**
```java
// âœ… Good: ì‹¤ì œ ì—…ë¬´ ê¸°ëŠ¥ ê¸°ë°˜ ì—­í• 
public enum Role {
    COMPLIANCE_OFFICER,      // ì¤€ë²•ê°ì‹œ ë‹´ë‹¹ì
    INVESTIGATOR,            // ì¡°ì‚¬ì
    APPROVER_ORG,            // ì¡°ì§ ìŠ¹ì¸ì
    APPROVER_COMPLIANCE,     // ì¤€ë²• ìŠ¹ì¸ì
    SYSTEM_ADMIN,            // ì‹œìŠ¤í…œ ê´€ë¦¬ì
    AUDITOR                  // ê°ì‚¬ì (ì½ê¸° ì „ìš©)
}

// âœ… Good: ìµœì†Œ ê¶Œí•œ ì›ì¹™ - ì‘ê³  ì§‘ì¤‘ëœ ê¶Œí•œ
@RequirePermission(feature = "case", action = "investigate")
public void investigateCase(String caseId) { ... }

@RequirePermission(feature = "case", action = "approve")
public void approveCase(String caseId) { ... }
```

**âŒ DON'T (ë¹„ê¶Œì¥):**
```java
// âŒ Bad: ë„ˆë¬´ í¬ê´„ì ì´ê±°ë‚˜ ëª¨í˜¸í•œ ì—­í• 
public enum Role {
    SUPER_USER,              // ë„ˆë¬´ ê´‘ë²”ìœ„
    GENERAL_STAFF,           // ì±…ì„ ë¶ˆëª…í™•
    POWER_USER               // ì˜ë¯¸ ëª¨í˜¸
}

// âŒ Bad: ë‹¨ì¼ omnipotent ì—­í• 
@RequirePermission(feature = "all", action = "all")
public void doEverything() { ... }
```

### 2. ì—­í•  í­ë°œ(Role Explosion) ë°©ì§€

**ë¬¸ì œ**: ì¡°ì§ì´ ì„±ì¥í•˜ë©´ì„œ ì—­í•  ìˆ˜ê°€ ê¸°í•˜ê¸‰ìˆ˜ì ìœ¼ë¡œ ì¦ê°€

**í•´ê²°ì±…**: Feature + Action ê¸°ë°˜ ì„¸ë¶„í™” ê¶Œí•œ ì²´ê³„

```java
/**
 * Feature-Action ê¸°ë°˜ ê¶Œí•œ êµ¬ì¡°
 * 
 * ì¥ì :
 * - ì—­í•  ìˆ˜ ì¦ê°€ ì—†ì´ ê¶Œí•œ ì¡°í•© ê°€ëŠ¥
 * - ë™ì  ê¶Œí•œ í• ë‹¹ ì§€ì›
 * - ì—­í•  ê°„ ëª…í™•í•œ ê²½ê³„
 */
@Entity
@Table(name = "permission")
public class Permission {
    
    @Id
    private String permissionId;
    
    @Column(nullable = false)
    private String feature;        // "case", "policy", "user", "report"
    
    @Column(nullable = false)
    private String action;         // "read", "write", "approve", "delete"
    
    /**
     * Permission ì¡°í•© ì˜ˆì‹œ:
     * - case:read         â†’ ì‚¬ë¡€ ì¡°íšŒ
     * - case:investigate  â†’ ì‚¬ë¡€ ì¡°ì‚¬
     * - case:approve      â†’ ì‚¬ë¡€ ìŠ¹ì¸
     * - policy:write      â†’ ì •ì±… ì‘ì„±
     * - policy:approve    â†’ ì •ì±… ìŠ¹ì¸
     * - report:submit     â†’ ë³´ê³ ì„œ ì œì¶œ
     */
}

// PermissionGroupìœ¼ë¡œ ì—­í•  êµ¬í˜„
@Entity
@Table(name = "permission_group")
public class PermissionGroup {
    
    @Id
    private String groupId;
    
    @Column(nullable = false)
    private String groupName;      // "INVESTIGATOR", "APPROVER_ORG"
    
    @ManyToMany
    @JoinTable(name = "permission_group_permission")
    private Set<Permission> permissions;
}
```

**í†µê³„ (2025 ê¸°ì¤€):**
- RBAC ì±„íƒë¥ : 94.7% (ì¡°ì§)
- í˜„ì¬ RBACë¥¼ ìµœìš°ì„  ëª¨ë¸ë¡œ ì‚¬ìš©: 86.6%

### 3. ì—­í•  ê³„ì¸µ êµ¬ì¡° (Role Hierarchy)

```java
/**
 * ì—­í•  ê³„ì¸µ êµ¬ì¡°
 * 
 * ì›ì¹™:
 * - ìƒìœ„ ì—­í• ì€ í•˜ìœ„ ì—­í• ì˜ ëª¨ë“  ê¶Œí•œ ìƒì†
 * - ê³„ì¸µì´ ê¹Šì–´ì§ˆìˆ˜ë¡ ê´€ë¦¬ ë³µì¡ë„ ì¦ê°€ (3ë‹¨ê³„ ì´ë‚´ ê¶Œì¥)
 */
public class RoleHierarchy {
    
    // Level 1: ìµœê³  ê´€ë¦¬ì
    SUPER_ADMIN
        â†“ (ìƒì†)
    // Level 2: ë¶€ì„œ ê´€ë¦¬ì
    COMPLIANCE_OFFICER
        â†“ (ìƒì†)
    // Level 3: ì‹¤ë¬´ì
    INVESTIGATOR
        â†“ (ìƒì†)
    // Level 4: ì½ê¸° ì „ìš©
    AUDITOR
}

// Spring Security ì„¤ì •
@Bean
public RoleHierarchyImpl roleHierarchy() {
    RoleHierarchyImpl hierarchy = new RoleHierarchyImpl();
    hierarchy.setHierarchy(
        "ROLE_SUPER_ADMIN > ROLE_COMPLIANCE_OFFICER
" +
        "ROLE_COMPLIANCE_OFFICER > ROLE_INVESTIGATOR
" +
        "ROLE_INVESTIGATOR > ROLE_AUDITOR"
    );
    return hierarchy;
}
```

---

## B. ì¡°ì§ ê³„ì¸µ ë° ê¶Œí•œ ìƒì† (Organization Hierarchy)

### 1. ê³„ì¸µ êµ¬ì¡° ë¯¸ëŸ¬ë§ ì›ì¹™

**ì›ì¹™**: ì‹œìŠ¤í…œì˜ ë¦¬ì†ŒìŠ¤ ê³„ì¸µì€ ì¡°ì§ êµ¬ì¡°ë¥¼ ë°˜ì˜í•´ì•¼ í•¨

```java
/**
 * ì¡°ì§ ê³„ì¸µ êµ¬ì¡°
 * 
 * Google Cloud ê¶Œì¥ ì‚¬í•­:
 * - ë¦¬ì†ŒìŠ¤ ê³„ì¸µì€ ì¡°ì§ êµ¬ì¡°ë¥¼ ë¯¸ëŸ¬ë§
 * - ì •ì±…ì€ ê³„ì¸µì ìœ¼ë¡œ ì „íŒŒ (ìƒìœ„ â†’ í•˜ìœ„)
 */
@Entity
@Table(name = "organization")
public class Organization {
    
    @Id
    private String orgId;
    
    @Column(nullable = false)
    private String orgName;
    
    @Column
    private String parentOrgId;        // ìƒìœ„ ì¡°ì§
    
    @Column(nullable = false)
    private Integer level;             // ê³„ì¸µ ë ˆë²¨ (1: ë³¸ì‚¬, 2: ì§€ì , 3: íŒ€)
    
    @Column
    private String orgPath;            // "/ë³¸ì‚¬/ì„œìš¸ì§€ì /ì¤€ë²•ê°ì‹œíŒ€"
    
    /**
     * ì¡°ì§ ê³„ì¸µ ì˜ˆì‹œ:
     * 
     * ë³¸ì‚¬ (Level 1)
     *  â”œâ”€ ì„œìš¸ì§€ì  (Level 2)
     *  â”‚   â”œâ”€ ì¤€ë²•ê°ì‹œíŒ€ (Level 3)
     *  â”‚   â””â”€ ì˜ì—…íŒ€ (Level 3)
     *  â””â”€ ë¶€ì‚°ì§€ì  (Level 2)
     *      â””â”€ ì¤€ë²•ê°ì‹œíŒ€ (Level 3)
     */
}
```

### 2. ê¶Œí•œ ìƒì† ì›ì¹™

**í•µì‹¬ ì›ì¹™:**
1. **í•˜í–¥ ì „íŒŒ**: ìƒìœ„ ì¡°ì§ ì •ì±…ì€ í•˜ìœ„ ì¡°ì§ìœ¼ë¡œ ìë™ ì „íŒŒ
2. **ëª…ì‹œì  ìš°ì„ **: ëª…ì‹œì  ê¶Œí•œì´ ìƒì†ëœ ê¶Œí•œë³´ë‹¤ ìš°ì„ 
3. **Deny ìš°ì„ **: Deny ê¶Œí•œì´ Allow ê¶Œí•œë³´ë‹¤ ìš°ì„ 

```java
/**
 * ê¶Œí•œ ìƒì† ë¡œì§
 */
@Service
@RequiredArgsConstructor
public class PermissionInheritanceService {
    
    private final OrganizationRepository organizationRepository;
    private final PolicyRepository policyRepository;
    
    /**
     * ì‚¬ìš©ìì˜ ìœ íš¨ ê¶Œí•œ ê³„ì‚° (ìƒì† í¬í•¨)
     * 
     * ìš°ì„ ìˆœìœ„:
     * 1. ëª…ì‹œì  Deny (ìµœìš°ì„ )
     * 2. ëª…ì‹œì  Allow
     * 3. ìƒì†ëœ Deny
     * 4. ìƒì†ëœ Allow
     * 5. ê¸°ë³¸ê°’ (Deny)
     */
    public Set<Permission> getEffectivePermissions(String userId) {
        User user = userRepository.findById(userId);
        Organization org = organizationRepository.findById(user.getOrgId());
        
        Set<Permission> effectivePermissions = new HashSet<>();
        
        // 1. ì‚¬ìš©ì ì§ì ‘ ê¶Œí•œ
        Set<Permission> directPermissions = user.getPermissions();
        
        // 2. ì¡°ì§ ê³„ì¸µì„ ë”°ë¼ ìƒìœ„ ì¡°ì§ ê¶Œí•œ ìˆ˜ì§‘
        Set<Permission> inheritedPermissions = collectInheritedPermissions(org);
        
        // 3. ë³‘í•© (ëª…ì‹œì  ê¶Œí•œ ìš°ì„ )
        effectivePermissions.addAll(directPermissions);
        effectivePermissions.addAll(inheritedPermissions);
        
        // 4. Deny ê¶Œí•œ í•„í„°ë§
        Set<Permission> denyPermissions = collectDenyPermissions(user, org);
        effectivePermissions.removeAll(denyPermissions);
        
        return effectivePermissions;
    }
    
    /**
     * ìƒìœ„ ì¡°ì§ ê¶Œí•œ ìƒì†
     */
    private Set<Permission> collectInheritedPermissions(Organization org) {
        Set<Permission> inherited = new HashSet<>();
        
        // í˜„ì¬ ì¡°ì§ë¶€í„° ìµœìƒìœ„ê¹Œì§€ ìˆœíšŒ
        Organization current = org;
        while (current != null) {
            DataPolicy policy = policyRepository.findByOrgId(current.getOrgId());
            if (policy != null) {
                inherited.addAll(policy.getAllowedPermissions());
            }
            
            // ìƒìœ„ ì¡°ì§ìœ¼ë¡œ ì´ë™
            current = (current.getParentOrgId() != null) 
                ? organizationRepository.findById(current.getParentOrgId()).orElse(null)
                : null;
        }
        
        return inherited;
    }
}
```

### 3. ê¶Œí•œ ì¶©ëŒ ì²˜ë¦¬

```java
/**
 * ê¶Œí•œ ì¶©ëŒ ì‹œë‚˜ë¦¬ì˜¤
 * 
 * ì‹œë‚˜ë¦¬ì˜¤: ì‚¬ìš©ìê°€ ì—¬ëŸ¬ ê·¸ë£¹ì— ì†í•´ ìˆê³ , ê·¸ë£¹ ê°„ ê¶Œí•œ ì¶©ëŒ
 * 
 * í•´ê²° ì›ì¹™:
 * - Explicit > Inherited
 * - Deny > Allow
 * - Lower Level > Higher Level (ë” êµ¬ì²´ì ì¸ ê²ƒ ìš°ì„ )
 */
public enum PermissionConflictResolution {
    
    /**
     * Example:
     * 
     * User: John
     * Group A: case:read (Allow)
     * Group B: case:read (Deny)
     * 
     * Result: Deny (Denyê°€ ìš°ì„ )
     */
    DENY_WINS_OVER_ALLOW,
    
    /**
     * Example:
     * 
     * Direct Permission: case:approve (Allow)
     * Inherited Permission: case:approve (Deny)
     * 
     * Result: Allow (Explicitê°€ ìš°ì„ )
     */
    EXPLICIT_WINS_OVER_INHERITED,
    
    /**
     * Example:
     * 
     * Organization Level 1 (ë³¸ì‚¬): case:read (Deny)
     * Organization Level 2 (ì§€ì ): case:read (Allow)
     * 
     * Result: Allow (Lower levelì´ ìš°ì„ )
     */
    LOWER_LEVEL_WINS
}
```

---

## C. ABAC (Attribute-Based Access Control) íŒ¨í„´

### 1. ABAC ì•„í‚¤í…ì²˜ êµ¬ì„± ìš”ì†Œ

```java
/**
 * ABAC ì•„í‚¤í…ì²˜
 * 
 * êµ¬ì„± ìš”ì†Œ:
 * - PEP (Policy Enforcement Point): API/ì»¨íŠ¸ë¡¤ëŸ¬ ë ˆì´ì–´
 * - PDP (Policy Decision Point): ì •ì±… í‰ê°€ ì—”ì§„
 * - PIP (Policy Information Point): ì†ì„± ë°ì´í„° ì†ŒìŠ¤
 */

// 1. PEP (Policy Enforcement Point) - AOPë¡œ êµ¬í˜„
@Aspect
@Component
@RequiredArgsConstructor
public class PermissionEnforcementAspect {
    
    private final PolicyDecisionPoint pdp;
    
    @Around("@annotation(requirePermission)")
    public Object enforce(ProceedingJoinPoint joinPoint, RequirePermission requirePermission) 
            throws Throwable {
        
        // 1. ìš”ì²­ ì»¨í…ìŠ¤íŠ¸ ì¶”ì¶œ
        String userId = SecurityContextHolder.getContext().getAuthentication().getName();
        String feature = requirePermission.feature();
        String action = requirePermission.action();
        Object resource = extractResource(joinPoint);
        
        // 2. PDPì— ê¶Œí•œ ê²°ì • ìš”ì²­
        AccessRequest request = AccessRequest.builder()
            .subject(userId)
            .resource(resource)
            .action(action)
            .feature(feature)
            .build();
        
        AccessDecision decision = pdp.evaluate(request);
        
        // 3. ê²°ì • ì§‘í–‰
        if (decision.isPermit()) {
            return joinPoint.proceed();
        } else {
            throw new AccessDeniedException(
                String.format("Access denied: %s:%s", feature, action)
            );
        }
    }
}

// 2. PDP (Policy Decision Point) - ì •ì±… í‰ê°€ ì—”ì§„
@Service
@RequiredArgsConstructor
public class PolicyDecisionPoint {
    
    private final PolicyInformationPoint pip;
    private final PolicyRepository policyRepository;
    
    /**
     * ì ‘ê·¼ ê²°ì • í‰ê°€
     * 
     * í‰ê°€ ìš”ì†Œ:
     * - Subject Attributes (ì‚¬ìš©ì: ì—­í• , ì¡°ì§, ë ˆë²¨)
     * - Resource Attributes (ë¦¬ì†ŒìŠ¤: íƒ€ì…, ì†Œìœ ì, ë¯¼ê°ë„)
     * - Action (ì‘ì—…: read, write, approve, delete)
     * - Environment (í™˜ê²½: ì‹œê°„, IP, ìœ„ì¹˜)
     */
    public AccessDecision evaluate(AccessRequest request) {
        
        // 1. Subject ì†ì„± ì¡°íšŒ
        UserAttributes subject = pip.getUserAttributes(request.getSubject());
        
        // 2. Resource ì†ì„± ì¡°íšŒ
        ResourceAttributes resource = pip.getResourceAttributes(request.getResource());
        
        // 3. Environment ì†ì„± ì¡°íšŒ
        EnvironmentAttributes environment = pip.getEnvironmentAttributes();
        
        // 4. ì •ì±… í‰ê°€
        List<Policy> policies = policyRepository.findApplicablePolicies(
            subject, resource, request.getAction()
        );
        
        // 5. ì •ì±… ê·œì¹™ í‰ê°€ (SpEL í‘œí˜„ì‹)
        for (Policy policy : policies) {
            boolean matches = evaluateSpELExpression(
                policy.getCondition(),
                subject,
                resource,
                environment
            );
            
            if (matches) {
                return policy.getEffect() == Effect.ALLOW 
                    ? AccessDecision.permit() 
                    : AccessDecision.deny(policy.getReason());
            }
        }
        
        // 6. ê¸°ë³¸ê°’: Deny
        return AccessDecision.deny("No matching policy found");
    }
    
    /**
     * SpEL í‘œí˜„ì‹ í‰ê°€
     * 
     * ì˜ˆì‹œ ì •ì±… ì¡°ê±´:
     * - "#subject.role == 'INVESTIGATOR' && #resource.status == 'ASSIGNED'"
     * - "#subject.orgId == #resource.orgId"
     * - "#environment.time.hour >= 9 && #environment.time.hour <= 18"
     */
    private boolean evaluateSpELExpression(
        String expression,
        UserAttributes subject,
        ResourceAttributes resource,
        EnvironmentAttributes environment
    ) {
        ExpressionParser parser = new SpelExpressionParser();
        StandardEvaluationContext context = new StandardEvaluationContext();
        
        context.setVariable("subject", subject);
        context.setVariable("resource", resource);
        context.setVariable("environment", environment);
        
        return parser.parseExpression(expression).getValue(context, Boolean.class);
    }
}

// 3. PIP (Policy Information Point) - ì†ì„± ë°ì´í„° ì†ŒìŠ¤
@Service
@RequiredArgsConstructor
public class PolicyInformationPoint {
    
    private final UserRepository userRepository;
    private final OrganizationRepository organizationRepository;
    
    public UserAttributes getUserAttributes(String userId) {
        User user = userRepository.findById(userId).orElseThrow();
        Organization org = organizationRepository.findById(user.getOrgId()).orElseThrow();
        
        return UserAttributes.builder()
            .userId(userId)
            .role(user.getRole())
            .orgId(user.getOrgId())
            .orgLevel(org.getLevel())
            .orgPath(org.getOrgPath())
            .build();
    }
    
    public ResourceAttributes getResourceAttributes(Object resource) {
        // ë¦¬ì†ŒìŠ¤ íƒ€ì…ì— ë”°ë¼ ì†ì„± ì¶”ì¶œ
        if (resource instanceof Case) {
            Case caseObj = (Case) resource;
            return ResourceAttributes.builder()
                .resourceType("case")
                .ownerId(caseObj.getCreatedBy())
                .orgId(caseObj.getOrgId())
                .status(caseObj.getStatus())
                .sensitivity(caseObj.getSensitivity())
                .build();
        }
        return ResourceAttributes.empty();
    }
    
    public EnvironmentAttributes getEnvironmentAttributes() {
        return EnvironmentAttributes.builder()
            .time(LocalDateTime.now())
            .ipAddress(getCurrentIpAddress())
            .build();
    }
}
```

### 2. Row-Level Security (RLS) êµ¬í˜„

```java
/**
 * Row-Level Security (í–‰ ìˆ˜ì¤€ ë³´ì•ˆ)
 * 
 * ëª©ì :
 * - ì‚¬ìš©ì ì†ì„±ì— ë”°ë¼ ë°ì´í„° í–‰(Row) ì ‘ê·¼ ì œí•œ
 * - ë™ì¼ í…Œì´ë¸”ì—ì„œ ì‚¬ìš©ìë§ˆë‹¤ ë‹¤ë¥¸ ë°ì´í„° ë³´ê¸°
 */
@Service
@RequiredArgsConstructor
public class RowLevelSecurityService {
    
    private final CaseRepository caseRepository;
    private final UserRepository userRepository;
    private final PolicyRepository policyRepository;
    
    /**
     * RowScope ì •ì±…ì— ë”°ë¥¸ ë°ì´í„° í•„í„°ë§
     * 
     * RowScope:
     * - OWN: ë³¸ì¸ì´ ìƒì„±í•œ ë°ì´í„°ë§Œ
     * - ORG: ë™ì¼ ì¡°ì§ ë°ì´í„°ë§Œ
     * - ALL: ëª¨ë“  ë°ì´í„°
     * - CUSTOM: ì‚¬ìš©ì ì •ì˜ ì¿¼ë¦¬
     */
    public List<Case> listCases(String userId) {
        User user = userRepository.findById(userId).orElseThrow();
        DataPolicy policy = policyRepository.findByRoleAndFeature(
            user.getRole(), 
            "case"
        );
        
        switch (policy.getRowScope()) {
            case OWN:
                // ë³¸ì¸ ìƒì„± ì‚¬ë¡€ë§Œ
                return caseRepository.findByCreatedBy(userId);
            
            case ORG:
                // ë™ì¼ ì¡°ì§ ì‚¬ë¡€ë§Œ
                return caseRepository.findByOrgId(user.getOrgId());
            
            case ORG_HIERARCHY:
                // ë³¸ì¸ ì¡°ì§ + í•˜ìœ„ ì¡°ì§ ì‚¬ë¡€
                List<String> orgIds = getOrgHierarchyIds(user.getOrgId());
                return caseRepository.findByOrgIdIn(orgIds);
            
            case ALL:
                // ëª¨ë“  ì‚¬ë¡€
                return caseRepository.findAll();
            
            case CUSTOM:
                // ì‚¬ìš©ì ì •ì˜ ì¿¼ë¦¬ (ì˜ˆ: íŠ¹ì • ìƒíƒœë§Œ)
                String customCondition = policy.getCustomCondition();
                return caseRepository.findByCustomCondition(customCondition);
            
            default:
                return Collections.emptyList();
        }
    }
    
    /**
     * ì¡°ì§ ê³„ì¸µ ê¸°ë°˜ RLS
     */
    private List<String> getOrgHierarchyIds(String orgId) {
        Organization org = organizationRepository.findById(orgId).orElseThrow();
        List<String> orgIds = new ArrayList<>();
        orgIds.add(orgId);
        
        // í•˜ìœ„ ì¡°ì§ ID ìˆ˜ì§‘ (ì¬ê·€)
        List<Organization> children = organizationRepository.findByParentOrgId(orgId);
        for (Organization child : children) {
            orgIds.addAll(getOrgHierarchyIds(child.getOrgId()));
        }
        
        return orgIds;
    }
}

/**
 * MyBatis Dynamic SQLë¡œ RLS êµ¬í˜„
 */
@Mapper
public interface CaseMapper {
    
    /**
     * Dynamic SQLë¡œ Row-Level í•„í„°ë§
     */
    @Select("""
        <script>
        SELECT * FROM \"case\"
        WHERE deleted = FALSE
        <if test="rowScope == 'OWN'">
          AND created_by = #{userId}
        </if>
        <if test="rowScope == 'ORG'">
          AND org_id = #{orgId}
        </if>
        <if test="rowScope == 'ORG_HIERARCHY'">
          AND org_id IN
          <foreach item="id" collection="orgIds" open="(" separator="," close=")">
            #{id}
          </foreach>
        </if>
        ORDER BY created_at DESC
        </script>
    """)
    List<Case> findWithRowLevelSecurity(
        @Param("rowScope") String rowScope,
        @Param("userId") String userId,
        @Param("orgId") String orgId,
        @Param("orgIds") List<String> orgIds
    );
}
```

### 3. Field-Level Masking (í•„ë“œ ìˆ˜ì¤€ ë§ˆìŠ¤í‚¹)

```java
/**
 * Field-Level Masking (í•„ë“œ ìˆ˜ì¤€ ë§ˆìŠ¤í‚¹)
 * 
 * ëª©ì :
 * - ë¯¼ê° ì •ë³´(PII) ë³´í˜¸
 * - ì—­í• /ê¶Œí•œì— ë”°ë¼ í•„ë“œë³„ ë§ˆìŠ¤í‚¹
 */
@Service
@RequiredArgsConstructor
public class FieldMaskingService {
    
    private final PolicyRepository policyRepository;
    
    /**
     * ë™ì  í•„ë“œ ë§ˆìŠ¤í‚¹
     */
    public <T> T maskSensitiveFields(T entity, String userId) {
        User user = userRepository.findById(userId).orElseThrow();
        DataPolicy policy = policyRepository.findByRole(user.getRole());
        
        // ë¦¬í”Œë ‰ì…˜ìœ¼ë¡œ @Sensitive í•„ë“œ ì°¾ê¸°
        Field[] fields = entity.getClass().getDeclaredFields();
        for (Field field : fields) {
            Sensitive sensitive = field.getAnnotation(Sensitive.class);
            if (sensitive != null) {
                String fieldName = field.getName();
                
                // ì •ì±…ì—ì„œ ë§ˆìŠ¤í‚¹ ì—¬ë¶€ í™•ì¸
                if (policy.shouldMask(fieldName)) {
                    field.setAccessible(true);
                    try {
                        Object originalValue = field.get(entity);
                        if (originalValue instanceof String) {
                            String maskedValue = mask(
                                (String) originalValue, 
                                sensitive.maskType()
                            );
                            field.set(entity, maskedValue);
                        }
                    } catch (IllegalAccessException e) {
                        log.error("Failed to mask field: {}", fieldName, e);
                    }
                }
            }
        }
        
        return entity;
    }
    
    /**
     * ë§ˆìŠ¤í‚¹ íƒ€ì…ë³„ ì²˜ë¦¬
     */
    private String mask(String value, MaskType type) {
        if (value == null) return null;
        
        switch (type) {
            case FULL:
                // "John Doe" â†’ "********"
                return "*".repeat(value.length());
            
            case PARTIAL:
                // "123-45-6789" â†’ "***-**-6789"
                if (value.length() <= 4) return "***";
                return "*".repeat(value.length() - 4) + value.substring(value.length() - 4);
            
            case EMAIL:
                // "john.doe@example.com" â†’ "j***e@example.com"
                int atIndex = value.indexOf('@');
                if (atIndex <= 2) return value;
                return value.charAt(0) + "***" + value.charAt(atIndex - 1) + value.substring(atIndex);
            
            case PHONE:
                // "010-1234-5678" â†’ "010-****-5678"
                String[] parts = value.split("-");
                if (parts.length != 3) return value;
                return parts[0] + "-****-" + parts[2];
            
            default:
                return value;
        }
    }
}

/**
 * @Sensitive ì–´ë…¸í…Œì´ì…˜
 */
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Sensitive {
    MaskType maskType() default MaskType.PARTIAL;
}

/**
 * Entityì— ì ìš©
 */
@Entity
@Table(name = "customer")
public class Customer {
    
    @Id
    private String customerId;
    
    private String name;
    
    @Sensitive(maskType = MaskType.PARTIAL)
    private String ssn;                 // ì£¼ë¯¼ë“±ë¡ë²ˆí˜¸
    
    @Sensitive(maskType = MaskType.EMAIL)
    private String email;
    
    @Sensitive(maskType = MaskType.PHONE)
    private String phoneNumber;
}
```

---

## D. Separation of Duties (SoD) ê°•í™”

```java
/**
 * Maker-Checker íŒ¨í„´ ê°•í™”
 * 
 * ì›ì¹™:
 * - ë™ì¼ ì‚¬ìš©ìê°€ ìƒì„±(Maker)ê³¼ ìŠ¹ì¸(Checker)ì„ ëª¨ë‘ ìˆ˜í–‰ ë¶ˆê°€
 * - ì´ì¤‘ í†µì œë¡œ ë‚´ë¶€ ë¶€ì • ë°©ì§€
 * - ê°ì‚¬ ì¶”ì  í•„ìˆ˜
 */
@Service
@RequiredArgsConstructor
public class SeparationOfDutiesService {
    
    private final AuditLogRepository auditLogRepository;
    
    /**
     * SoD ìœ„ë°˜ ê²€ì¦
     */
    public void validateSoD(String resourceId, String approverId, String action) {
        // 1. ë¦¬ì†ŒìŠ¤ ìƒì„±ì í™•ì¸
        AuditLog creationLog = auditLogRepository.findByResourceIdAndAction(
            resourceId, 
            "CREATE"
        );
        
        String makerId = creationLog.getUserId();
        
        // 2. Maker-Checker ê²€ì¦
        if (makerId.equals(approverId)) {
            throw new SeparationOfDutiesViolationException(
                String.format(
                    "SoD Violation: User %s cannot both create and %s resource %s",
                    approverId, action, resourceId
                )
            );
        }
        
        // 3. ì¡°ì§ ì •ì±… ê²€ì¦ (ì„ íƒì )
        OrganizationPolicy policy = policyRepository.findByOrgId(
            getUserOrg(approverId)
        );
        
        if (policy.isRequireDualControl()) {
            // ì´ì¤‘ ìŠ¹ì¸ í•„ìš”
            long approvalCount = auditLogRepository.countByResourceIdAndAction(
                resourceId, 
                "APPROVE"
            );
            
            if (approvalCount < 1) {
                throw new DualControlRequiredException(
                    "This resource requires at least 2 approvals"
                );
            }
        }
    }
    
    /**
     * ìŠ¹ì¸ ì²´ì¸ ê²€ì¦
     */
    public void validateApprovalChain(String resourceId, String approverId) {
        List<AuditLog> approvalHistory = auditLogRepository.findApprovalHistory(resourceId);
        
        // 1. ë™ì¼ ì‚¬ìš©ìê°€ ì—¬ëŸ¬ ë²ˆ ìŠ¹ì¸í•˜ì§€ ëª»í•˜ë„ë¡
        boolean alreadyApproved = approvalHistory.stream()
            .anyMatch(log -> log.getUserId().equals(approverId));
        
        if (alreadyApproved) {
            throw new DuplicateApprovalException(
                "User has already approved this resource"
            );
        }
        
        // 2. ìŠ¹ì¸ ìˆœì„œ ê²€ì¦ (ê³„ì¸µì  ìŠ¹ì¸)
        User approver = userRepository.findById(approverId).orElseThrow();
        int approverLevel = getApprovalLevel(approver.getRole());
        
        for (AuditLog log : approvalHistory) {
            User previousApprover = userRepository.findById(log.getUserId()).orElseThrow();
            int previousLevel = getApprovalLevel(previousApprover.getRole());
            
            if (approverLevel <= previousLevel) {
                throw new ApprovalOrderViolationException(
                    "Approval must follow hierarchical order"
                );
            }
        }
    }
    
    private int getApprovalLevel(String role) {
        Map<String, Integer> levelMap = Map.of(
            "INVESTIGATOR", 1,
            "APPROVER_ORG", 2,
            "APPROVER_COMPLIANCE", 3,
            "COMPLIANCE_OFFICER", 4
        );
        return levelMap.getOrDefault(role, 0);
    }
}
```

---

## E. ì„±ëŠ¥ ìµœì í™” ì „ëµ

### 1. ê¶Œí•œ ìºì‹±

```java
/**
 * ê¶Œí•œ ê³„ì‚° ê²°ê³¼ ìºì‹±
 * 
 * ë¬¸ì œ:
 * - ë³µì¡í•œ ì¡°ì§ ê³„ì¸µ ìˆœíšŒëŠ” ì„±ëŠ¥ ì €í•˜
 * - ë§¤ ìš”ì²­ë§ˆë‹¤ ê¶Œí•œ ì¬ê³„ì‚° ë¹„íš¨ìœ¨ì 
 * 
 * í•´ê²°:
 * - Redis ìºì‹± (TTL: 5ë¶„)
 * - ê¶Œí•œ ë³€ê²½ ì‹œ ìºì‹œ ë¬´íš¨í™”
 */
@Service
@RequiredArgsConstructor
public class CachedPermissionService {
    
    private final RedisTemplate<String, Set<Permission>> redisTemplate;
    private final PermissionInheritanceService inheritanceService;
    
    private static final String PERMISSION_CACHE_PREFIX = "permission:user:";
    private static final long CACHE_TTL = 300; // 5 minutes
    
    @Cacheable(
        value = "userPermissions",
        key = "#userId",
        unless = "#result == null"
    )
    public Set<Permission> getEffectivePermissions(String userId) {
        String cacheKey = PERMISSION_CACHE_PREFIX + userId;
        
        // 1. ìºì‹œ ì¡°íšŒ
        Set<Permission> cached = redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }
        
        // 2. ê³„ì‚°
        Set<Permission> permissions = inheritanceService.getEffectivePermissions(userId);
        
        // 3. ìºì‹œ ì €ì¥
        redisTemplate.opsForValue().set(cacheKey, permissions, CACHE_TTL, TimeUnit.SECONDS);
        
        return permissions;
    }
    
    /**
     * ìºì‹œ ë¬´íš¨í™” (ê¶Œí•œ ë³€ê²½ ì‹œ)
     */
    @CacheEvict(value = "userPermissions", key = "#userId")
    public void invalidateUserPermissions(String userId) {
        String cacheKey = PERMISSION_CACHE_PREFIX + userId;
        redisTemplate.delete(cacheKey);
        
        log.info("Invalidated permission cache for user: {}", userId);
    }
    
    /**
     * ì¡°ì§ ë‹¨ìœ„ ìºì‹œ ë¬´íš¨í™”
     */
    public void invalidateOrgPermissions(String orgId) {
        List<User> users = userRepository.findByOrgId(orgId);
        for (User user : users) {
            invalidateUserPermissions(user.getUserId());
        }
        
        log.info("Invalidated permission cache for organization: {}", orgId);
    }
}
```

### 2. ì¡°ì§ ê³„ì¸µ ê²½ë¡œ ìµœì í™”

```java
/**
 * ì¡°ì§ ê²½ë¡œ ì‚¬ì „ ê³„ì‚°
 * 
 * ë¬¸ì œ:
 * - ì¬ê·€ ì¿¼ë¦¬ë¡œ ì¡°ì§ ê³„ì¸µ íƒìƒ‰ì€ O(n) ë³µì¡ë„
 * 
 * í•´ê²°:
 * - orgPath í•„ë“œì— ì „ì²´ ê²½ë¡œ ì‚¬ì „ ì €ì¥
 * - ì¿¼ë¦¬ í•œ ë²ˆìœ¼ë¡œ ìƒìœ„ ì¡°ì§ í™•ì¸
 */
@Entity
@Table(name = "organization")
public class Organization {
    
    @Id
    private String orgId;
    
    @Column
    private String parentOrgId;
    
    /**
     * ì¡°ì§ ê²½ë¡œ (Materialized Path Pattern)
     * 
     * ì˜ˆì‹œ:
     * - "/ë³¸ì‚¬"
     * - "/ë³¸ì‚¬/ì„œìš¸ì§€ì "
     * - "/ë³¸ì‚¬/ì„œìš¸ì§€ì /ì¤€ë²•ê°ì‹œíŒ€"
     * 
     * ì¥ì :
     * - ìƒìœ„ ì¡°ì§ í™•ì¸: orgPath LIKE '/ë³¸ì‚¬/ì„œìš¸ì§€ì %'
     * - í•˜ìœ„ ì¡°ì§ í™•ì¸: orgPath LIKE '%/ì¤€ë²•ê°ì‹œíŒ€'
     */
    @Column(nullable = false)
    private String orgPath;
    
    @Column
    private Integer level;
}

// MyBatis ì¿¼ë¦¬
@Mapper
public interface OrganizationMapper {
    
    /**
     * ì¡°ì§ ê³„ì¸µ ì¡°íšŒ (ë‹¨ì¼ ì¿¼ë¦¬)
     */
    @Select("""
        SELECT * FROM organization
        WHERE org_path LIKE CONCAT(#{orgPath}, '%')
        ORDER BY level ASC
    """)
    List<Organization> findHierarchy(@Param("orgPath") String orgPath);
    
    /**
     * ìƒìœ„ ì¡°ì§ ì¡°íšŒ
     */
    @Select("""
        SELECT * FROM organization
        WHERE #{orgPath} LIKE CONCAT(org_path, '%')
          AND org_id != #{orgId}
        ORDER BY level ASC
    """)
    List<Organization> findAncestors(
        @Param("orgId") String orgId,
        @Param("orgPath") String orgPath
    );
}
```

---

## F. ë³´ì•ˆ ë° ê°ì‚¬ ê°•í™”

### 1. ê¶Œí•œ ë³€ê²½ ê°ì‚¬

```java
/**
 * ê¶Œí•œ ë³€ê²½ 100% ê°ì‚¬ ë¡œê¹…
 */
@Aspect
@Component
@RequiredArgsConstructor
public class PermissionAuditAspect {
    
    private final AuditLogRepository auditLogRepository;
    
    @AfterReturning(
        pointcut = "@annotation(com.inspecthub.common.annotation.AuditPermissionChange)",
        returning = "result"
    )
    public void auditPermissionChange(JoinPoint joinPoint, Object result) {
        String userId = SecurityContextHolder.getContext().getAuthentication().getName();
        Object[] args = joinPoint.getArgs();
        
        AuditLog log = AuditLog.builder()
            .userId(userId)
            .action("PERMISSION_CHANGE")
            .resource("PERMISSION")
            .beforeValue(serializeArgs(args))
            .afterValue(serialize(result))
            .timestamp(LocalDateTime.now())
            .result("SUCCESS")
            .build();
        
        auditLogRepository.insert(log);
    }
}
```

### 2. ë¹„ì •ìƒ íŒ¨í„´ íƒì§€

```java
/**
 * ê¶Œí•œ ìƒìŠ¹ ì‹œë„ íƒì§€
 */
@Service
@RequiredArgsConstructor
public class PrivilegeEscalationDetector {
    
    private final AuditLogRepository auditLogRepository;
    private final AlertService alertService;
    
    @Scheduled(fixedDelay = 60000) // 1ë¶„ë§ˆë‹¤
    public void detectSuspiciousActivity() {
        LocalDateTime threshold = LocalDateTime.now().minusMinutes(10);
        
        // 1. ì§§ì€ ì‹œê°„ ë‚´ ë°˜ë³µ ê¶Œí•œ ì²´í¬ ì‹¤íŒ¨
        List<AuditLog> failedAttempts = auditLogRepository.findByResultAndTimestampAfter(
            "FAILURE", 
            threshold
        );
        
        Map<String, Long> failuresByUser = failedAttempts.stream()
            .collect(Collectors.groupingBy(AuditLog::getUserId, Collectors.counting()));
        
        failuresByUser.forEach((userId, count) -> {
            if (count >= 5) {
                alertService.send(
                    "Security Alert",
                    String.format(
                        "User %s has %d failed permission checks in 10 minutes",
                        userId, count
                    )
                );
            }
        });
        
        // 2. ë¹„ì •ìƒ ì‹œê°„ëŒ€ ì ‘ê·¼
        int currentHour = LocalDateTime.now().getHour();
        if (currentHour < 6 || currentHour > 22) {
            List<AuditLog> offHoursAccess = auditLogRepository.findByTimestampHour(currentHour);
            if (!offHoursAccess.isEmpty()) {
                alertService.send(
                    "Security Alert",
                    String.format(
                        "%d access attempts during off-hours",
                        offHoursAccess.size()
                    )
                );
            }
        }
    }
}
```

---

## G. í…ŒìŠ¤íŠ¸ ì „ëµ

### 1. ê¶Œí•œ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸

```java
/**
 * ê¶Œí•œ ì‹œìŠ¤í…œ í†µí•© í…ŒìŠ¤íŠ¸
 */
@SpringBootTest
@Transactional
class PermissionSystemIntegrationTest {
    
    @Autowired
    private PermissionInheritanceService permissionService;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private OrganizationRepository organizationRepository;
    
    @Test
    @DisplayName("ìƒìœ„ ì¡°ì§ ì •ì±…ì´ í•˜ìœ„ ì¡°ì§ìœ¼ë¡œ ìƒì†ëœë‹¤")
    void shouldInheritPermissionsFromParentOrg() {
        // Given: ì¡°ì§ ê³„ì¸µ ìƒì„±
        Organization hq = createOrganization("ë³¸ì‚¬", null, "/ë³¸ì‚¬", 1);
        Organization branch = createOrganization("ì„œìš¸ì§€ì ", hq.getOrgId(), "/ë³¸ì‚¬/ì„œìš¸ì§€ì ", 2);
        Organization team = createOrganization("ì¤€ë²•ê°ì‹œíŒ€", branch.getOrgId(), "/ë³¸ì‚¬/ì„œìš¸ì§€ì /ì¤€ë²•ê°ì‹œíŒ€", 3);
        
        // ë³¸ì‚¬ì— ì •ì±… í• ë‹¹
        DataPolicy hqPolicy = createPolicy(hq.getOrgId(), Set.of("case:read", "case:write"));
        
        // ì‚¬ìš©ì ìƒì„± (ì¤€ë²•ê°ì‹œíŒ€ ì†Œì†)
        User user = createUser("john", team.getOrgId());
        
        // When: ìœ íš¨ ê¶Œí•œ ê³„ì‚°
        Set<Permission> effectivePermissions = permissionService.getEffectivePermissions(user.getUserId());
        
        // Then: ìƒìœ„ ì¡°ì§ ê¶Œí•œ ìƒì† í™•ì¸
        assertThat(effectivePermissions)
            .extracting(Permission::getCode)
            .contains("case:read", "case:write");
    }
    
    @Test
    @DisplayName("Deny ê¶Œí•œì´ Allow ê¶Œí•œë³´ë‹¤ ìš°ì„ í•œë‹¤")
    void shouldDenyWinOverAllow() {
        // Given
        User user = createUser("john", "org1");
        
        // ì§ì ‘ ê¶Œí•œ: case:read (Allow)
        assignPermission(user, "case:read", Effect.ALLOW);
        
        // ê·¸ë£¹ ê¶Œí•œ: case:read (Deny)
        PermissionGroup group = createGroup("Restricted Group");
        assignGroupPermission(group, "case:read", Effect.DENY);
        addUserToGroup(user, group);
        
        // When
        Set<Permission> effectivePermissions = permissionService.getEffectivePermissions(user.getUserId());
        
        // Then: Denyê°€ ìš°ì„ 
        assertThat(effectivePermissions)
            .extracting(Permission::getCode)
            .doesNotContain("case:read");
    }
    
    @Test
    @DisplayName("SoD ìœ„ë°˜ ì‹œ ì˜ˆì™¸ê°€ ë°œìƒí•œë‹¤")
    void shouldThrowExceptionOnSoDViolation() {
        // Given
        String caseId = createCase("john");
        
        // When & Then
        assertThatThrownBy(() -> 
            separationOfDutiesService.validateSoD(caseId, "john", "APPROVE"))
            .isInstanceOf(SeparationOfDutiesViolationException.class)
            .hasMessageContaining("cannot both create and APPROVE");
    }
}
```

---

## H. ë§ˆì´ê·¸ë ˆì´ì…˜ ë° ë¡¤ë°± ì „ëµ

```java
/**
 * ê¶Œí•œ ì‹œìŠ¤í…œ ë§ˆì´ê·¸ë ˆì´ì…˜
 * 
 * ì‹œë‚˜ë¦¬ì˜¤: ë ˆê±°ì‹œ Role ê¸°ë°˜ â†’ Feature-Action ê¸°ë°˜ ì „í™˜
 */
@Service
@RequiredArgsConstructor
public class PermissionMigrationService {
    
    private final UserRepository userRepository;
    private final PermissionRepository permissionRepository;
    
    /**
     * ë‹¨ê³„ì  ë§ˆì´ê·¸ë ˆì´ì…˜ (Strangler Fig Pattern)
     */
    public void migratePermissions() {
        // 1. ê¸°ì¡´ Roleì„ PermissionGroupìœ¼ë¡œ ë³€í™˜
        List<User> users = userRepository.findAll();
        
        for (User user : users) {
            String legacyRole = user.getRole();
            
            // 2. Roleì— í•´ë‹¹í•˜ëŠ” Permission ë§¤í•‘
            Set<Permission> permissions = mapRoleToPermissions(legacyRole);
            
            // 3. PermissionGroup ìƒì„± ë° í• ë‹¹
            PermissionGroup group = PermissionGroup.builder()
                .groupId(UlidCreator.getUlid().toString())
                .groupName(legacyRole)
                .permissions(permissions)
                .build();
            
            permissionGroupRepository.insert(group);
            
            // 4. ì‚¬ìš©ìì—ê²Œ ê·¸ë£¹ í• ë‹¹
            assignGroupToUser(user.getUserId(), group.getGroupId());
            
            log.info("Migrated user {} from role {} to permission group", 
                user.getUserId(), legacyRole);
        }
    }
    
    /**
     * ë¡¤ë°± ì „ëµ
     */
    public void rollbackMigration() {
        // PermissionGroupì„ ë‹¤ì‹œ Roleë¡œ ë³€í™˜
        List<UserPermissionGroup> assignments = userPermissionGroupRepository.findAll();
        
        for (UserPermissionGroup assignment : assignments) {
            PermissionGroup group = permissionGroupRepository.findById(assignment.getGroupId());
            String roleName = group.getGroupName();
            
            User user = userRepository.findById(assignment.getUserId());
            user.setRole(roleName);
            userRepository.update(user);
            
            log.info("Rolled back user {} to role {}", user.getUserId(), roleName);
        }
    }
    
    private Set<Permission> mapRoleToPermissions(String role) {
        // ì—­í• ë³„ ê¶Œí•œ ë§¤í•‘ ë¡œì§
        Map<String, Set<String>> rolePermissionMap = Map.of(
            "INVESTIGATOR", Set.of("case:read", "case:investigate", "case:write"),
            "APPROVER_ORG", Set.of("case:read", "case:approve"),
            "COMPLIANCE_OFFICER", Set.of("case:*", "policy:*", "report:submit")
        );
        
        Set<String> permissionCodes = rolePermissionMap.getOrDefault(role, Set.of());
        return permissionRepository.findByCodes(permissionCodes);
    }
}
```

---

## I. ì²´í¬ë¦¬ìŠ¤íŠ¸: ê¶Œí•œ ì‹œìŠ¤í…œ ì„¤ê³„ ê²€í† 

### âœ… RBAC ì„¤ê³„

- [ ] ì—­í• ì€ ì‹¤ì œ ì—…ë¬´ ê¸°ëŠ¥ ê¸°ë°˜ìœ¼ë¡œ ì •ì˜ë˜ì—ˆëŠ”ê°€?
- [ ] ì—­í•  ê³„ì¸µì€ 3ë‹¨ê³„ ì´ë‚´ì¸ê°€?
- [ ] Feature-Action ê¸°ë°˜ìœ¼ë¡œ ê¶Œí•œì„ ì„¸ë¶„í™”í–ˆëŠ”ê°€?
- [ ] ì—­í•  í­ë°œ(Role Explosion)ì„ ë°©ì§€í–ˆëŠ”ê°€?
- [ ] ìµœì†Œ ê¶Œí•œ ì›ì¹™ì„ ì ìš©í–ˆëŠ”ê°€?

### âœ… ì¡°ì§ ê³„ì¸µ ë° ìƒì†

- [ ] ì¡°ì§ êµ¬ì¡°ê°€ ì‹œìŠ¤í…œ ê³„ì¸µì— ë¯¸ëŸ¬ë§ë˜ì—ˆëŠ”ê°€?
- [ ] ê¶Œí•œ ìƒì† ê·œì¹™ì´ ëª…í™•í•œê°€? (Explicit > Inherited, Deny > Allow)
- [ ] orgPath ì‚¬ì „ ê³„ì‚°ìœ¼ë¡œ ì¿¼ë¦¬ ì„±ëŠ¥ ìµœì í™”í–ˆëŠ”ê°€?
- [ ] ê¶Œí•œ ì¶©ëŒ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ ì •ì˜í•˜ê³  í•´ê²° ê·œì¹™ì„ ëª…ì‹œí–ˆëŠ”ê°€?

### âœ… ABAC êµ¬í˜„

- [ ] PEP, PDP, PIP ì•„í‚¤í…ì²˜ê°€ ëª…í™•íˆ ë¶„ë¦¬ë˜ì—ˆëŠ”ê°€?
- [ ] SpEL í‘œí˜„ì‹ìœ¼ë¡œ ë™ì  ì •ì±… í‰ê°€ê°€ ê°€ëŠ¥í•œê°€?
- [ ] Subject, Resource, Action, Environment ì†ì„±ì„ ëª¨ë‘ ê³ ë ¤í–ˆëŠ”ê°€?

### âœ… Row-Level Security

- [ ] RowScope ì •ì±…(OWN, ORG, ALL, CUSTOM)ì„ ì •ì˜í–ˆëŠ”ê°€?
- [ ] Dynamic SQLë¡œ í–‰ ìˆ˜ì¤€ í•„í„°ë§ì„ êµ¬í˜„í–ˆëŠ”ê°€?
- [ ] ì¡°ì§ ê³„ì¸µ ê¸°ë°˜ RLSë¥¼ ì§€ì›í•˜ëŠ”ê°€?

### âœ… Field-Level Masking

- [ ] @Sensitive ì–´ë…¸í…Œì´ì…˜ìœ¼ë¡œ ë¯¼ê° í•„ë“œë¥¼ í‘œì‹œí–ˆëŠ”ê°€?
- [ ] MaskTypeë³„ ë§ˆìŠ¤í‚¹ ë¡œì§ì„ êµ¬í˜„í–ˆëŠ”ê°€? (FULL, PARTIAL, EMAIL, PHONE)
- [ ] ì—­í• ë³„ë¡œ ë§ˆìŠ¤í‚¹ ì •ì±…ì„ ë‹¤ë¥´ê²Œ ì ìš©í•  ìˆ˜ ìˆëŠ”ê°€?

### âœ… SoD (Separation of Duties)

- [ ] Maker-Checker ì›ì¹™ì„ ì ìš©í–ˆëŠ”ê°€?
- [ ] ë™ì¼ ì‚¬ìš©ìê°€ ìƒì„±+ìŠ¹ì¸ì„ ëª¨ë‘ í•  ìˆ˜ ì—†ë„ë¡ ê²€ì¦í•˜ëŠ”ê°€?
- [ ] ìŠ¹ì¸ ì²´ì¸(ê³„ì¸µì  ìŠ¹ì¸)ì„ ê²€ì¦í•˜ëŠ”ê°€?
- [ ] ì´ì¤‘ ìŠ¹ì¸ ì •ì±…ì„ ì§€ì›í•˜ëŠ”ê°€?

### âœ… ì„±ëŠ¥ ìµœì í™”

- [ ] ê¶Œí•œ ê³„ì‚° ê²°ê³¼ë¥¼ ìºì‹±í•˜ëŠ”ê°€? (Redis, TTL: 5ë¶„)
- [ ] ê¶Œí•œ ë³€ê²½ ì‹œ ìºì‹œë¥¼ ë¬´íš¨í™”í•˜ëŠ”ê°€?
- [ ] orgPathë¡œ ì¡°ì§ ê³„ì¸µ ì¿¼ë¦¬ë¥¼ ìµœì í™”í–ˆëŠ”ê°€?

### âœ… ë³´ì•ˆ ë° ê°ì‚¬

- [ ] ëª¨ë“  ê¶Œí•œ ë³€ê²½ì„ ê°ì‚¬ ë¡œê·¸ì— ê¸°ë¡í•˜ëŠ”ê°€?
- [ ] ë¹„ì •ìƒ íŒ¨í„´(ë°˜ë³µ ì‹¤íŒ¨, ê¶Œí•œ ìƒìŠ¹ ì‹œë„)ì„ íƒì§€í•˜ëŠ”ê°€?
- [ ] ì˜¤í”„-ì•„ì›Œ ì ‘ê·¼ì„ ëª¨ë‹ˆí„°ë§í•˜ëŠ”ê°€?

### âœ… í…ŒìŠ¤íŠ¸ ì „ëµ

- [ ] ê¶Œí•œ ìƒì† í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í–ˆëŠ”ê°€?
- [ ] Deny > Allow ìš°ì„ ìˆœìœ„ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í–ˆëŠ”ê°€?
- [ ] SoD ìœ„ë°˜ í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í–ˆëŠ”ê°€?
- [ ] Row-Level Security í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í–ˆëŠ”ê°€?
- [ ] Field-Level Masking í…ŒìŠ¤íŠ¸ë¥¼ ì‘ì„±í–ˆëŠ”ê°€?

### âœ… ë§ˆì´ê·¸ë ˆì´ì…˜

- [ ] ë ˆê±°ì‹œ ì‹œìŠ¤í…œì—ì„œ ë§ˆì´ê·¸ë ˆì´ì…˜ ê³„íšì´ ìˆëŠ”ê°€?
- [ ] Strangler Fig Patternìœ¼ë¡œ ë‹¨ê³„ì  ì „í™˜í•˜ëŠ”ê°€?
- [ ] ë¡¤ë°± ì „ëµì´ ì¤€ë¹„ë˜ì–´ ìˆëŠ”ê°€?

---
