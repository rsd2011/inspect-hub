# ⚡ 성능 고려사항

## 1. 예외 생성 비용

**문제**: 예외 객체 생성은 비용이 높음 (스택 트레이스 생성)

**해결방법:**

```java
// ❌ Bad: 반복문에서 예외 생성
for (String id : ids) {
    try {
        processUser(id);
    } catch (UserNotFoundException e) {
        // 예외를 흐름 제어로 사용 - 성능 저하
    }
}

// ✅ Good: 예외 대신 Optional 사용
for (String id : ids) {
    userRepository.findById(id)
            .ifPresent(this::processUser);
}
```

## 2. 스택 트레이스 비활성화 (특수 상황)

**고성능이 필요한 경우에만 사용:**

```java
public class PerformanceOptimizedException extends RuntimeException {
    
    public PerformanceOptimizedException(String message) {
        super(message);
    }
    
    /**
     * 스택 트레이스 비활성화 (성능 최적화)
     * 주의: 디버깅이 어려워지므로 신중히 사용
     */
    @Override
    public synchronized Throwable fillInStackTrace() {
        return this; // 스택 트레이스 생성 건너뛰기
    }
}
```

## 3. 예외 캐싱 (Singleton Pattern)

**극단적 최적화 (일반적으로 권장하지 않음):**

```java
public class OptimizedExceptions {
    
    // ⚠️ 주의: 스택 트레이스가 재사용되어 디버깅 어려움
    public static final BusinessException USER_NOT_FOUND = 
            new BusinessException(ErrorCode.AUTH_001);
    
    public static final BusinessException INVALID_PASSWORD = 
            new BusinessException(ErrorCode.AUTH_002);
}

// 사용
throw OptimizedExceptions.USER_NOT_FOUND; // ⚠️ 스택 트레이스 부정확
```

## 4. 로깅 성능 고려

```java
// ❌ Bad: 무거운 연산을 로그 메시지에 직접 포함
log.debug("User data: {}", expensiveToStringMethod()); // toString() 항상 실행

// ✅ Good: isDebugEnabled() 체크
if (log.isDebugEnabled()) {
    log.debug("User data: {}", expensiveToStringMethod());
}

// ✅ Better: Lazy evaluation (Logback/SLF4J 지원)
log.debug("User data: {}", () -> expensiveToStringMethod());
```

---
