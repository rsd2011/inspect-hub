# 코드 품질 기준

## 1. 중복 제거 (Ruthlessly Eliminate Duplication)

**DO:**
- ✅ 중복 코드를 발견하면 즉시 제거
- ✅ Extract Method, Extract Class 사용
- ✅ 공통 로직을 Domain Service로 추출

**예제:**

```java
// ❌ 중복 코드
public class PolicyService {
    public void approvePolicy(PolicyId id) {
        Policy policy = policyRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("Policy not found"));
        policy.approve();
        policyRepository.save(policy);
    }

    public void rejectPolicy(PolicyId id, String reason) {
        Policy policy = policyRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("Policy not found"));
        policy.reject(reason);
        policyRepository.save(policy);
    }
}

// ✅ 중복 제거
public class PolicyService {
    public void approvePolicy(PolicyId id) {
        Policy policy = findPolicyOrThrow(id);
        policy.approve();
        savePolicy(policy);
    }

    public void rejectPolicy(PolicyId id, String reason) {
        Policy policy = findPolicyOrThrow(id);
        policy.reject(reason);
        savePolicy(policy);
    }

    private Policy findPolicyOrThrow(PolicyId id) {
        return policyRepository.findById(id)
            .orElseThrow(() -> new EntityNotFoundException("Policy not found"));
    }

    private void savePolicy(Policy policy) {
        policyRepository.save(policy);
    }
}
```

## 2. 의도 명확화 (Express Intent Clearly)

**DO:**
- ✅ 의미 있는 변수/메서드/클래스 이름 사용
- ✅ 주석 대신 코드로 의도 표현
- ✅ Magic Number 상수화

**예제:**

```java
// ❌ 의도 불명확
public class User {
    private int s; // 상태?

    public boolean check() {
        return s == 1;
    }
}

// ✅ 의도 명확
public class User {
    private static final int ACTIVE_STATUS = 1;
    private int status;

    public boolean isActive() {
        return status == ACTIVE_STATUS;
    }
}

// 더 나은 방법: Enum 사용
public class User {
    private UserStatus status;

    public boolean isActive() {
        return status == UserStatus.ACTIVE;
    }
}
```

## 3. 의존성 명시화 (Make Dependencies Explicit)

**DO:**
- ✅ 생성자 주입 사용 (필드 주입 금지)
- ✅ 인터페이스 기반 의존성
- ✅ 필요한 의존성만 주입

**예제:**

```java
// ❌ 필드 주입 (암묵적 의존성)
@Service
public class PolicyService {
    @Autowired
    private PolicyRepository policyRepository;

    @Autowired
    private PolicyDomainService policyDomainService;
}

// ✅ 생성자 주입 (명시적 의존성)
@Service
@RequiredArgsConstructor
public class PolicyService {
    private final PolicyRepository policyRepository;
    private final PolicyDomainService policyDomainService;

    // Lombok @RequiredArgsConstructor가 생성자 자동 생성
}
```

## 4. 단일 책임 (Single Responsibility)

**DO:**
- ✅ 메서드는 하나의 일만 수행
- ✅ 클래스는 하나의 책임만
- ✅ 메서드 길이 20줄 이하 권장

**예제:**

```java
// ❌ 여러 책임
public class UserService {
    public void registerUser(UserRequest request) {
        // 1. 검증
        if (request.getEmail() == null) throw new IllegalArgumentException();
        if (!request.getEmail().contains("@")) throw new IllegalArgumentException();

        // 2. 중복 체크
        if (userRepository.existsByEmail(request.getEmail())) {
            throw new DuplicateUserException();
        }

        // 3. 비밀번호 암호화
        String hashedPassword = BCrypt.hashpw(request.getPassword(), BCrypt.gensalt());

        // 4. 엔티티 생성
        User user = new User(request.getEmail(), hashedPassword);

        // 5. 저장
        userRepository.save(user);

        // 6. 이메일 전송
        emailService.sendWelcomeEmail(user.getEmail());
    }
}

// ✅ 단일 책임 (각 단계를 메서드로 분리)
public class UserService {
    public void registerUser(UserRequest request) {
        validateRequest(request);
        checkDuplicateEmail(request.getEmail());

        User user = createUser(request);
        userRepository.save(user);

        sendWelcomeEmail(user);
    }

    private void validateRequest(UserRequest request) {
        // 검증 로직
    }

    private void checkDuplicateEmail(String email) {
        // 중복 체크 로직
    }

    private User createUser(UserRequest request) {
        // 엔티티 생성 로직
    }

    private void sendWelcomeEmail(User user) {
        // 이메일 전송 로직
    }
}
```

## 5. 상태 최소화 (Minimize State)

**DO:**
- ✅ Immutable 객체 선호 (Value Object)
- ✅ 순수 함수 선호 (부작용 최소화)
- ✅ final 키워드 적극 사용

**예제:**

```java
// ❌ Mutable (변경 가능)
public class Email {
    private String value;

    public void setValue(String value) {
        this.value = value;
    }
}

// ✅ Immutable (불변)
public class Email {
    private final String value;

    public Email(String value) {
        validate(value);
        this.value = value;
    }

    public String getValue() {
        return value;
    }

    private void validate(String value) {
        if (!value.contains("@")) {
            throw new IllegalArgumentException("유효하지 않은 이메일 형식입니다");
        }
    }
}
```

## 6. 가장 단순한 해결책 (Simplest Solution)

**DO:**
- ✅ YAGNI (You Aren't Gonna Need It)
- ✅ 과도한 일반화 지양
- ✅ 미래를 위한 코드 작성 금지

**예제:**

```java
// ❌ 과도한 일반화 (현재 필요 없음)
public interface PolicyValidator {
    boolean validate(Policy policy);
}

public class UniqueNameValidator implements PolicyValidator {
    public boolean validate(Policy policy) { ... }
}

public class StatusValidator implements PolicyValidator {
    public boolean validate(Policy policy) { ... }
}

// ✅ 단순한 해결책 (현재 필요한 것만)
public class PolicyDomainService {
    public void validateUniqueness(Policy policy) {
        // 현재 필요한 검증만 구현
    }
}
```

---
