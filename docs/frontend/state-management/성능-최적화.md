# 성능 최적화

## 1. Computed 캐싱 활용

```typescript
// ✅ Good: Computed 사용 (캐싱됨)
const expensiveComputation = computed(() => {
  return users.value
    .filter(u => u.active)
    .map(u => ({
      ...u,
      displayName: `${u.fullName} (${u.username})`
    }))
    .sort((a, b) => a.displayName.localeCompare(b.displayName))
})

// ❌ Bad: 매번 재계산
function getActiveUsers() {
  return users.value
    .filter(u => u.active)
    .map(u => ({ /* ... */ }))
    .sort(/* ... */)
}
```

## 2. 선택적 구독 (Storelets)

```typescript
// ✅ Good: 필요한 state만 구독
const { user, isAuthenticated } = storeToRefs(useAuthStore())

// ❌ Bad: 전체 store 반응형으로 만들기
const authStore = toRefs(useAuthStore())  // 모든 state가 반응형
```

## 3. 대용량 리스트 관리

```typescript
// entities/case/model/case.store.ts
export const useCaseStore = defineStore('case', () => {
  const cases = ref<Case[]>([])
  const caseMap = ref<Map<string, Case>>(new Map())  // 빠른 조회용

  async function fetchCases() {
    const response = await caseApi.getCases()
    
    if (response.success) {
      cases.value = response.data.items
      
      // Map으로도 저장 (O(1) 조회)
      response.data.items.forEach(c => {
        caseMap.value.set(c.id, c)
      })
    }
  }

  // ✅ O(1) 조회
  function getCaseById(id: string) {
    return caseMap.value.get(id)
  }

  // ❌ O(n) 조회 (피하기)
  // function getCaseById(id: string) {
  //   return cases.value.find(c => c.id === id)
  // }

  return {
    cases,
    fetchCases,
    getCaseById
  }
})
```

## 4. Debounce/Throttle

```typescript
// shared/lib/composables/useSearch.ts
import { debounce } from 'lodash-es'

export function useSearch() {
  const searchQuery = ref('')
  const results = ref([])

  const debouncedSearch = debounce(async (query: string) => {
    const response = await searchApi.search(query)
    results.value = response.data
  }, 300)

  watch(searchQuery, (newQuery) => {
    debouncedSearch(newQuery)
  })

  return {
    searchQuery,
    results
  }
}
```

---
