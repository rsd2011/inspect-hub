# 베스트 프랙티스

## 필수 준수 사항 (MUST)

### TDD + BDD 필수 준수 체크리스트

**모든 새로운 기능은 다음을 따라야 합니다:**

- [ ] **Red**: 실패하는 테스트를 먼저 작성했는가?
- [ ] **Green**: 최소한의 코드로 테스트를 통과시켰는가?
- [ ] **Refactor**: 테스트가 통과한 상태에서 코드를 개선했는가?
- [ ] **Given-When-Then**: 각 테스트가 명확한 3단계 구조를 따르는가?
- [ ] **한글 시나리오**: 테스트 설명이 비즈니스 요구사항을 반영하는가?
- [ ] **사용자 관점**: 구현이 아닌 행동을 검증하는가?

## 10가지 실용적인 가이드라인

### 1. 테스트 이름은 시나리오로 작성

**✅ Good:**
```typescript
it('사용자가 잘못된 비밀번호를 5회 입력하면 계정이 잠긴다', () => {})
it('VIP 고객에게 20% 할인이 자동으로 적용된다', () => {})
it('만료된 세션으로 API 호출 시 로그인 페이지로 리다이렉트된다', () => {})
```

**❌ Bad:**
```typescript
it('should work', () => {})
it('test login', () => {})
it('password validation', () => {})
```

### 2. Given-When-Then 주석 활용

**✅ Good:**
```typescript
it('장바구니에 상품 추가 시 총액이 업데이트된다', () => {
  // Given: 빈 장바구니
  const cart = useCartStore()
  expect(cart.items).toHaveLength(0)

  // When: 상품 추가
  cart.addItem({ id: '123', name: '노트북', price: 1000000 })

  // Then: 총액 확인
  expect(cart.total).toBe(1000000)
  expect(cart.items).toHaveLength(1)
})
```

**❌ Bad:**
```typescript
it('cart test', () => {
  const cart = useCartStore()
  cart.addItem({ id: '123', name: '노트북', price: 1000000 })
  expect(cart.total).toBe(1000000)
})
```

### 3. 접근성 쿼리 우선 사용

**✅ Good (사용자 관점):**
```typescript
// 역할 기반
screen.getByRole('button', { name: '저장' })
screen.getByRole('textbox', { name: '이메일' })
screen.getByRole('heading', { name: '대시보드' })

// 레이블 기반
screen.getByLabelText('비밀번호')
screen.getByLabelText('생년월일')

// 텍스트 기반
screen.getByText('로그인 성공')
```

**❌ Bad (구현 세부사항):**
```typescript
wrapper.find('.btn-primary')
wrapper.find('#email-input')
wrapper.vm.$refs.saveButton
```

### 4. 비동기 처리는 waitFor 사용

**✅ Good:**
```typescript
it('API 응답 후 사용자 목록을 표시한다', async () => {
  render(UserList)

  await waitFor(() => {
    expect(screen.getByText('홍길동')).toBeInTheDocument()
    expect(screen.getByText('김철수')).toBeInTheDocument()
  })
})
```

**❌ Bad (플래키 테스트):**
```typescript
it('user list test', async () => {
  render(UserList)
  await new Promise(resolve => setTimeout(resolve, 1000))  // ❌ 고정 딜레이
  expect(screen.getByText('홍길동')).toBeInTheDocument()
})
```

### 5. 테스트 데이터는 명확하고 의미 있게

**✅ Good:**
```typescript
const validUser = {
  username: 'testuser',
  email: 'test@example.com',
  password: 'ValidPass123!'
}

const invalidEmail = 'not-an-email'
const expiredToken = 'eyJhbGciOiJIUzI1NiJ9.expired.signature'
```

**❌ Bad:**
```typescript
const user = { u: 'a', e: 'b', p: 'c' }
const data = 'test'
const val = 123
```

### 6. 모킹은 최소화, 필요한 경우만 사용

**✅ Good (실제 컴포넌트 테스트):**
```typescript
it('버튼 클릭 시 카운터가 증가한다', async () => {
  const { getByRole, getByText } = render(Counter)
  const button = getByRole('button', { name: '증가' })

  await userEvent.click(button)

  expect(getByText('카운트: 1')).toBeInTheDocument()
})
```

**❌ Bad (과도한 모킹):**
```typescript
it('counter test', () => {
  const mockIncrement = vi.fn()
  const wrapper = mount(Counter, {
    props: { onIncrement: mockIncrement }
  })
  wrapper.vm.increment()
  expect(mockIncrement).toHaveBeenCalled()
})
```

### 7. E2E 테스트는 명시적 대기 사용

**✅ Good:**
```typescript
test('로그인 후 대시보드 표시', async ({ page }) => {
  await page.goto('/login')
  await page.getByLabel('사용자명').fill('admin')
  await page.getByLabel('비밀번호').fill('admin123')
  await page.getByRole('button', { name: '로그인' }).click()

  // 명시적 대기
  await expect(page).toHaveURL('/dashboard')
  await expect(page.getByRole('heading', { name: '대시보드' })).toBeVisible()
})
```

**❌ Bad:**
```typescript
test('login', async ({ page }) => {
  await page.goto('/login')
  await page.fill('#username', 'admin')
  await page.fill('#password', 'admin123')
  await page.click('.submit')
  await page.waitForTimeout(2000)  // ❌ 임의의 대기
  expect(page.url()).toContain('dashboard')
})
```

### 8. 테스트 격리 보장

**✅ Good:**
```typescript
describe('UserStore', () => {
  beforeEach(() => {
    setActivePinia(createPinia())  // 매 테스트마다 새로운 Pinia
  })

  it('사용자 추가', () => {
    const store = useUserStore()
    store.addUser({ id: '1', name: '홍길동' })
    expect(store.users).toHaveLength(1)
  })

  it('사용자 삭제', () => {
    const store = useUserStore()
    // 이전 테스트와 독립적
    expect(store.users).toHaveLength(0)
  })
})
```

**❌ Bad:**
```typescript
const sharedStore = useUserStore()  // ❌ 전역 상태

it('test 1', () => {
  sharedStore.addUser({ id: '1', name: '홍길동' })
})

it('test 2', () => {
  // test 1의 영향을 받음
  expect(sharedStore.users).toHaveLength(1)
})
```

### 9. 예외 처리 검증

**✅ Good:**
```typescript
it('중복된 이메일로 가입 시 에러를 표시한다', async () => {
  const { getByLabel, getByRole, getByText } = render(SignupForm)

  // Given: 기존 사용자와 동일한 이메일
  await userEvent.type(getByLabel('이메일'), 'existing@example.com')

  // When: 가입 시도
  await userEvent.click(getByRole('button', { name: '가입' }))

  // Then: 에러 메시지 표시
  await waitFor(() => {
    expect(getByText('이미 사용 중인 이메일입니다')).toBeInTheDocument()
  })
})
```

**❌ Bad:**
```typescript
it('error test', async () => {
  render(SignupForm)
  // 에러 시나리오 미검증
  expect(wrapper.exists()).toBe(true)
})
```

### 10. 테스트 가독성 우선

**✅ Good:**
```typescript
describe('할인 계산', () => {
  const createVIPUser = () => ({ level: 'VIP', purchases: 100 })
  const createNormalUser = () => ({ level: 'NORMAL', purchases: 10 })

  it('VIP 고객은 20% 할인을 받는다', () => {
    const user = createVIPUser()
    const discount = calculateDiscount(user)
    expect(discount).toBe(0.20)
  })

  it('일반 고객은 할인이 없다', () => {
    const user = createNormalUser()
    const discount = calculateDiscount(user)
    expect(discount).toBe(0.0)
  })
})
```

**❌ Bad:**
```typescript
describe('discount', () => {
  it('test1', () => {
    expect(calc({ l: 'V', p: 100 })).toBe(0.2)
  })

  it('test2', () => {
    expect(calc({ l: 'N', p: 10 })).toBe(0)
  })
})
```

## 추가 권장 사항

**✅ DO:**
- 사용자 관점에서 테스트 작성
- 명확한 테스트 이름 사용 (`describe`, `it`)
- Given-When-Then 패턴 적용
- 접근성 우선 쿼리 사용 (`getByRole`, `getByLabel`)
- 모킹은 최소화, 실제 구현 우선
- 테스트 실패 시 원인을 명확히 파악할 수 있도록 작성

**❌ DON'T:**
- 구현 세부사항 테스트 (내부 state, private method)
- 과도한 스냅샷 테스트
- 여러 테스트 간 상태 공유
- 하드코딩된 타임아웃 사용
- 플래키(Flaky) 테스트 방치
- 한 테스트에서 여러 개념 검증

## 2. 컴포넌트 테스트 팁

```typescript
// ✅ Good: 사용자 관점 테스트
test('로그인 성공 시 대시보드로 이동', async () => {
  const { getByLabel, getByRole } = render(LoginForm)
  
  await user.type(getByLabel('사용자명'), 'admin')
  await user.type(getByLabel('비밀번호'), 'admin123')
  await user.click(getByRole('button', { name: '로그인' }))
  
  expect(mockRouter.push).toHaveBeenCalledWith('/dashboard')
})

// ❌ Bad: 구현 세부사항 테스트
test('loginMethod 호출 시 username과 password 전달', async () => {
  const wrapper = mount(LoginForm)
  wrapper.vm.loginMethod('admin', 'admin123')  // 내부 메서드 직접 호출
  expect(wrapper.vm.username).toBe('admin')  // 내부 state 검증
})
```

## 3. 비동기 테스트

```typescript
// ✅ Good: waitFor 사용
test('데이터 로딩 후 표시', async () => {
  render(UserList)
  
  await waitFor(() => {
    expect(screen.getByText('testuser')).toBeInTheDocument()
  })
})

// ❌ Bad: 고정 타임아웃
test('데이터 로딩', async () => {
  render(UserList)
  await new Promise(resolve => setTimeout(resolve, 1000))  // 플래키!
  expect(screen.getByText('testuser')).toBeInTheDocument()
})
```

## 4. E2E 테스트 안정성

```typescript
// ✅ Good: 명시적 대기
await page.waitForSelector('[data-testid="user-list"]')
await page.click('button[name="save"]')

// ❌ Bad: 임의의 타임아웃
await page.waitForTimeout(1000)
await page.click('button')
```

## 5. 테스트 데이터 관리

```typescript
// tests/fixtures/users.ts
export const mockUsers = {
  admin: {
    id: '01HGW2N7XKQJBZ9VFQR8X7Y3ZT',
    username: 'admin',
    email: 'admin@example.com',
    roles: ['ROLE_ADMIN']
  },
  user: {
    id: '01HGW2N7XKQJBZ9VFQR8X7Y3ZU',
    username: 'user',
    email: 'user@example.com',
    roles: ['ROLE_USER']
  }
}

// 테스트에서 사용
import { mockUsers } from '../fixtures/users'

test('관리자 권한 확인', () => {
  const store = useAuthStore()
  store.$patch({ user: mockUsers.admin })
  
  expect(store.hasRole('ROLE_ADMIN')).toBe(true)
})
```

---
